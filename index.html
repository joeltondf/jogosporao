<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
  <title>Spore Evolution - Fase Célula</title>
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: #000814;
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      color: #c8f4ff;
    }

    canvas {
      display: block;
      touch-action: none;
    }

    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 10px 14px;
      background: rgba(0, 20, 40, 0.4);
      border: 1px solid rgba(0, 255, 255, 0.2);
      border-radius: 12px;
      box-shadow: 0 0 12px rgba(0, 255, 255, 0.2);
      pointer-events: none;
      font-size: 14px;
      letter-spacing: 0.4px;
    }
  </style>
</head>
<body>
  <div id="ui">DNA: <span id="dnaScore">0</span></div>
  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const dnaLabel = document.getElementById("dnaScore");

    const backgroundColor = "rgba(0, 8, 20, 0.25)";
    const waterParticleCount = 140;
    const foodCount = 40;
    const lerpFactor = 0.06;

    const state = {
      width: window.innerWidth,
      height: window.innerHeight,
      frame: 0,
      pointerActive: false,
    };

    /**
     * Ajusta o tamanho do canvas ao viewport.
     */
    function resizeCanvas() {
      state.width = window.innerWidth;
      state.height = window.innerHeight;
      canvas.width = state.width * window.devicePixelRatio;
      canvas.height = state.height * window.devicePixelRatio;
      canvas.style.width = `${state.width}px`;
      canvas.style.height = `${state.height}px`;
      ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
    }

    const player = {
      x: state.width / 2,
      y: state.height / 2,
      radius: 22,
      maxRadius: 80,
      colorCore: "rgba(0, 255, 200, 0.6)",
      colorGlow: "rgba(0, 200, 255, 0.3)",
      targetX: state.width / 2,
      targetY: state.height / 2,
      dna: 0,
      wobbleSeed: Math.random() * 1000,
    };

    const foods = [];
    const waterParticles = [];

    /**
     * Retorna um valor aleatório em um intervalo.
     * @param {number} min
     * @param {number} max
     * @returns {number}
     */
    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }

    /**
     * Gera uma comida em posição aleatória.
     */
    function spawnFood() {
      foods.push({
        x: rand(40, state.width - 40),
        y: rand(40, state.height - 40),
        radius: rand(4, 7),
        color: `hsl(${rand(120, 220)}, 70%, 55%)`,
        pulse: rand(0, Math.PI * 2),
      });
    }

    /**
     * Inicializa partículas aquáticas de fundo.
     */
    function initWaterParticles() {
      waterParticles.length = 0;
      for (let i = 0; i < waterParticleCount; i += 1) {
        waterParticles.push({
          x: rand(0, state.width),
          y: rand(0, state.height),
          radius: rand(1, 3.5),
          speed: rand(0.2, 0.7),
          alpha: rand(0.1, 0.6),
        });
      }
    }

    /**
     * Atualiza as partículas de fundo para criar a sensação de água viva.
     */
    function updateWaterParticles() {
      waterParticles.forEach((particle) => {
        particle.y -= particle.speed;
        particle.x += Math.sin((state.frame + particle.y) * 0.004) * 0.4;
        if (particle.y < -10) {
          particle.y = state.height + 10;
          particle.x = rand(0, state.width);
        }
      });
    }

    /**
     * Desenha partículas de fundo.
     */
    function drawWaterParticles() {
      waterParticles.forEach((particle) => {
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(80, 190, 255, ${particle.alpha})`;
        ctx.fill();
      });
    }

    /**
     * Atualiza a posição do jogador com interpolação suave.
     */
    function updatePlayer() {
      player.x += (player.targetX - player.x) * lerpFactor;
      player.y += (player.targetY - player.y) * lerpFactor;
      player.radius = Math.min(player.radius, player.maxRadius);
    }

    /**
     * Desenha a célula orgânica com círculos e brilho.
     */
    function drawPlayer() {
      const pulse = Math.sin(state.frame * 0.06 + player.wobbleSeed) * 1.2;
      const outerRadius = player.radius + pulse;

      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.beginPath();
      ctx.arc(player.x, player.y, outerRadius * 1.6, 0, Math.PI * 2);
      ctx.fillStyle = player.colorGlow;
      ctx.fill();
      ctx.restore();

      ctx.beginPath();
      ctx.arc(player.x, player.y, outerRadius, 0, Math.PI * 2);
      ctx.fillStyle = player.colorCore;
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(240, 255, 255, 0.6)";
      ctx.stroke();

      for (let i = 0; i < 4; i += 1) {
        const angle = state.frame * 0.01 + i * 1.6;
        const orbRadius = player.radius * 0.32;
        const offset = player.radius * 0.45;
        const orbX = player.x + Math.cos(angle) * offset;
        const orbY = player.y + Math.sin(angle) * offset;
        ctx.beginPath();
        ctx.arc(orbX, orbY, orbRadius, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0, 140, 200, 0.35)";
        ctx.fill();
      }
    }

    /**
     * Atualiza comidas e detecta colisões.
     */
    function updateFoods() {
      foods.forEach((food, index) => {
        food.pulse += 0.05;
        const dist = Math.hypot(player.x - food.x, player.y - food.y);
        if (dist < player.radius + food.radius) {
          foods.splice(index, 1);
          player.dna += 10;
          player.radius += 0.6;
          dnaLabel.textContent = player.dna;
          spawnFood();
        }
      });
    }

    /**
     * Desenha as partículas de comida.
     */
    function drawFoods() {
      foods.forEach((food) => {
        const pulse = Math.sin(food.pulse) * 1.2;
        ctx.beginPath();
        ctx.arc(food.x, food.y, food.radius + pulse * 0.2, 0, Math.PI * 2);
        ctx.fillStyle = food.color;
        ctx.fill();
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
        ctx.stroke();
      });
    }

    /**
     * Loop principal.
     */
    function loop() {
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, state.width, state.height);

      updateWaterParticles();
      drawWaterParticles();
      updatePlayer();
      updateFoods();
      drawFoods();
      drawPlayer();

      state.frame += 1;
      window.requestAnimationFrame(loop);
    }

    function handlePointerMove(event) {
      player.targetX = event.clientX;
      player.targetY = event.clientY;
      state.pointerActive = true;
    }

    function handlePointerLeave() {
      if (!state.pointerActive) {
        return;
      }
      player.targetX = state.width / 2;
      player.targetY = state.height / 2;
      state.pointerActive = false;
    }

    window.addEventListener("resize", () => {
      resizeCanvas();
    });

    window.addEventListener("pointermove", handlePointerMove);
    window.addEventListener("pointerdown", handlePointerMove);
    window.addEventListener("pointerleave", handlePointerLeave);

    resizeCanvas();
    initWaterParticles();
    for (let i = 0; i < foodCount; i += 1) {
      spawnFood();
    }
    loop();
  </script>
</body>
</html>
